const path = require('path');
const fs = require('fs');

function generateModelClass(modelName, modelConfig) {
  if (!modelConfig || !modelConfig.fields) {
    throw new Error(`Invalid model configuration for ${modelName}: missing fields`);
  }

  // Track which fields and constants are actually used
  const usedFields = new Set();
  const usedConstants = new Set();

  // Field type mapping
  const fieldTypeMap = {
    'ulid': 'UlidField',
    'string': 'StringField',
    'relation': 'RelatedField',
    'createDate': 'CreateDateField',
    'version': 'VersionField',
    'modifiedDate': 'ModifiedDateField'
  };

  // Generate fields and track used field types
  const fields = Object.entries(modelConfig.fields)
    .map(([fieldName, fieldConfig]) => {
      const fieldClass = fieldTypeMap[fieldConfig.type] || 
        `${fieldConfig.type.charAt(0).toUpperCase()}${fieldConfig.type.slice(1)}Field`;
      
      usedFields.add(fieldClass);
      
      if (fieldConfig.type === 'relation') {
        return `    ${fieldName}: ${fieldClass}('${fieldConfig.model}', { required: ${!!fieldConfig.required} }),`;
      }

      const options = [];
      if (fieldConfig.required) options.push('required: true');
      if (fieldConfig.autoAssign) options.push('autoAssign: true');
      
      const optionsStr = options.length ? `{ ${options.join(', ')} }` : '';
      return `    ${fieldName}: ${fieldClass}(${optionsStr}),`;
    })
    .join('\n');

  // Generate indexes and track used constants
  const indexes = modelConfig.indexes ? Object.entries(modelConfig.indexes)
    .map(([indexName, indexConfig]) => {
      const indexId = `GSI_INDEX_ID${indexConfig.indexId.slice(-1)}`;
      usedConstants.add(indexId);
      return `    ${indexName}: IndexConfig('${indexConfig.partitionKey}', '${indexConfig.sortKey}', ${indexId}),`;
    })
    .join('\n') : '';

  // Generate unique constraints and track used constants
  const uniqueConstraints = modelConfig.uniqueConstraints ? Object.entries(modelConfig.uniqueConstraints)
    .map(([constraintName, constraintConfig]) => {
      const constraintId = `UNIQUE_CONSTRAINT_ID${constraintConfig.uniqueConstraintId.slice(-1)}`;
      usedConstants.add(constraintId);
      return `    ${constraintName}: UniqueConstraintConfig('${constraintConfig.field}', ${constraintId}),`;
    })
    .join('\n') : '';

  // Always need these
  usedConstants.add('PrimaryKeyConfig');
  if (indexes) usedConstants.add('IndexConfig');
  if (uniqueConstraints) usedConstants.add('UniqueConstraintConfig');

  // Generate imports based on what's used
  const constantImports = Array.from(usedConstants).join(',\n  ');
  const fieldImports = Array.from(usedFields).join(',\n    ');

  return `// Generated by model-codegen
const { 
  BaseModel, 
  ${constantImports}
} = require('dynamo-bao');

const { 
    ${fieldImports}
} = require('dynamo-bao').fields;

class ${modelName} extends BaseModel {
  static modelPrefix = '${modelConfig.modelPrefix}';
  
  static fields = {
${fields}
  };

  static primaryKey = PrimaryKeyConfig('${modelConfig.primaryKey.field}');
${indexes ? `\n  static indexes = {\n${indexes}\n  };` : ''}
${uniqueConstraints ? `\n  static uniqueConstraints = {\n${uniqueConstraints}\n  };` : ''}
}

module.exports = { ${modelName} };
`;
}

function generateModels(definitions, outputDir) {
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  Object.entries(definitions.models).forEach(([modelName, modelConfig]) => {
    const code = generateModelClass(modelName, modelConfig);
    const outputPath = path.join(outputDir, `${modelName.toLowerCase()}.js`);
    fs.writeFileSync(outputPath, code);
    console.log(`Generated ${outputPath}`);
  });
}

module.exports = { generateModels };
