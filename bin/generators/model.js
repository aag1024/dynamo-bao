const path = require('path');
const fs = require('fs');

function generateModelClass(modelName, modelConfig, allModels) {
  if (!modelConfig || !modelConfig.fields) {
    throw new Error(`Invalid model configuration for ${modelName}: missing fields`);
  }

  // Track which fields, constants, and models are actually used
  const usedFields = new Set();
  const usedConstants = new Set();

  // Field type mapping
  const fieldTypeMap = {
    'ulid': 'UlidField',
    'string': 'StringField',
    'relation': 'RelatedField',
    'createDate': 'CreateDateField',
    'version': 'VersionField',
    'modifiedDate': 'ModifiedDateField'
  };

  // Generate fields and track used field types
  const fields = Object.entries(modelConfig.fields)
    .map(([fieldName, fieldConfig]) => {
      const fieldClass = fieldTypeMap[fieldConfig.type] || 
        `${fieldConfig.type.charAt(0).toUpperCase()}${fieldConfig.type.slice(1)}Field`;
      
      usedFields.add(fieldClass);
      
      if (fieldConfig.type === 'relation') {
        return `    ${fieldName}: ${fieldClass}('${fieldConfig.model}', { required: ${!!fieldConfig.required} }),`;
      }

      const options = [];
      if (fieldConfig.required) options.push('required: true');
      if (fieldConfig.autoAssign) options.push('autoAssign: true');
      
      const optionsStr = options.length ? `{ ${options.join(', ')} }` : '';
      return `    ${fieldName}: ${fieldClass}(${optionsStr}),`;
    })
    .join('\n');

  // Handle primary key configuration
  const partitionKey = modelConfig.primaryKey.partitionKey;
  const sortKey = modelConfig.primaryKey.sortKey || 'modelPrefix';
  console.log(`Generating primary key for ${modelName}:`, { partitionKey, sortKey });
  const primaryKeyConfig = `PrimaryKeyConfig('${partitionKey}', '${sortKey}')`;

  // Generate indexes and track used constants
  const indexes = modelConfig.indexes ? Object.entries(modelConfig.indexes)
    .map(([indexName, indexConfig]) => {
      if (indexConfig === 'primaryKey') {
        return `    ${indexName}: this.primaryKey,`;
      }

      // Log the index configuration for debugging
      console.log(`Generating index ${indexName}:`, indexConfig);
      
      const indexId = `GSI_INDEX_ID${indexConfig.indexId.slice(-1)}`;
      usedConstants.add(indexId);
      return `    ${indexName}: IndexConfig('${indexConfig.partitionKey}', '${indexConfig.sortKey}', ${indexId}),`;
    })
    .join('\n') : '';

  // Generate unique constraints and track used constants
  const uniqueConstraints = modelConfig.uniqueConstraints ? Object.entries(modelConfig.uniqueConstraints)
    .map(([constraintName, constraintConfig]) => {
      const constraintId = `UNIQUE_CONSTRAINT_ID${constraintConfig.uniqueConstraintId.slice(-1)}`;
      usedConstants.add(constraintId);
      return `    ${constraintName}: UniqueConstraintConfig('${constraintConfig.field}', ${constraintId}),`;
    })
    .join('\n') : '';

  // Always need these
  usedConstants.add('PrimaryKeyConfig');
  if (indexes) usedConstants.add('IndexConfig');
  if (uniqueConstraints) usedConstants.add('UniqueConstraintConfig');

  // Generate imports based on what's used
  const constantImports = Array.from(usedConstants).join(',\n  ');
  const fieldImports = Array.from(usedFields).join(',\n    ');

  // Generate query methods and track related models
  const { methods: queryMethods, relatedModels } = generateQueryMethods(modelName, modelConfig, allModels);
  
  // Convert model names to kebab-case for imports
  const modelImports = Array.from(relatedModels).map(model => {
    const kebabName = model
      .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
      .toLowerCase();
    return `const { ${model} } = require('./${kebabName}');`
  }).join('\n');

  // Generate unique constraint lookup methods
  const uniqueConstraintMethods = generateUniqueConstraintMethods(modelConfig);

  return `// ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨  
// DO NOT EDIT: Generated by model-codegen 
// ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ 

const { 
  BaseModel, 
  ${constantImports}
} = require('dynamo-bao');

const { 
    ${fieldImports}
} = require('dynamo-bao').fields;

${modelImports}

class ${modelName} extends BaseModel {
  static modelPrefix = '${modelConfig.modelPrefix}';
  
  static fields = {
${fields}
  };

  static primaryKey = ${primaryKeyConfig};
${indexes ? `\n  static indexes = {\n${indexes}\n  };` : ''}
${uniqueConstraints ? `\n  static uniqueConstraints = {\n${uniqueConstraints}\n  };` : ''}
${queryMethods}
${uniqueConstraintMethods}
}

module.exports = { ${modelName} };
`;
}

function generateUniqueConstraintMethods(modelConfig) {
  if (!modelConfig.uniqueConstraints) return '';

  return Object.entries(modelConfig.uniqueConstraints)
    .map(([name, constraint]) => {
      const methodName = `cgFindBy${name.replace(/^unique/, '')}`;
      const constraintId = `_${constraint.uniqueConstraintId}`;
      return `
  static async ${methodName}(value) {
    return await this.findByUniqueConstraint('${constraintId}', '${constraint.field}', value);
  }`;
    })
    .join('\n');
}

function generateModelFiles(models, outputDir) {
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  Object.entries(models).forEach(([modelName, modelConfig]) => {
    const code = generateModelClass(modelName, modelConfig, models);
    
    // Convert model name from PascalCase to kebab-case for the file name
    const fileName = modelName
      .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
      .toLowerCase();
    
    const filePath = path.join(outputDir, `${fileName}.js`);
    fs.writeFileSync(filePath, code);
    console.log(`Generated ${filePath}`);
  });
}

function generateQueryMethods(modelName, modelConfig, allModels) {
  let methods = '';
  const relatedModels = new Set();

  // First, generate methods for indexes that use modelPrefix (self-referential queries)
  if (modelConfig.indexes) {
    Object.entries(modelConfig.indexes).forEach(([indexName, index]) => {
      if (index !== 'primaryKey' && index.partitionKey === 'modelPrefix') {
        let methodName;
        if (indexName.includes('For')) {
          const [prefix] = indexName.split('For');
          methodName = `cgQuery${prefix.charAt(0).toUpperCase()}${prefix.slice(1)}`;
        } else {
          methodName = `cgQuery${indexName.charAt(0).toUpperCase()}${indexName.slice(1)}`;
        }

        methods += `
  static async ${methodName}(skCondition = null, options = {}) {
    const results = await this.queryByIndex(
      '${indexName}',
      this.modelPrefix,
      skCondition,
      options
    );

    return results;
  }`;
      }
    });
  }

  // Then generate methods for other models that have relations to this model
  Object.entries(allModels).forEach(([otherModelName, otherModel]) => {
    if (otherModel.indexes) {
      Object.entries(otherModel.indexes).forEach(([indexName, index]) => {
        let pkField;
        
        if (index === 'primaryKey') {
          pkField = otherModel.fields[otherModel.primaryKey.partitionKey];
        } else {
          pkField = otherModel.fields[index.partitionKey];
        }

        if (pkField && pkField.type === 'relation' && pkField.model === modelName) {
          relatedModels.add(otherModelName);

          let methodName;
          if (indexName.includes('For')) {
            const [prefix] = indexName.split('For');
            methodName = `cgQuery${prefix.charAt(0).toUpperCase()}${prefix.slice(1)}`;
          } else {
            methodName = `cgQuery${indexName.charAt(0).toUpperCase()}${indexName.slice(1)}`;
          }

          methods += `
  async ${methodName}(skCondition = null, options = {}) {
    const results = await ${otherModelName}.queryByIndex(
      '${indexName}',
      this.getPkValue(),
      skCondition,
      options
    );

    return results;
  }`;
        }
      });
    }
  });

  return { methods, relatedModels };
}

module.exports = { generateModelFiles };
