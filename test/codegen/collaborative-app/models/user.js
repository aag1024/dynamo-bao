// ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨  
// DO NOT EDIT: Generated by model-codegen 
// ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ ðŸ§¨ 
const { 
  BaoModel,
  PrimaryKeyConfig,
  UniqueConstraintConfig
} = require('../../../../src/model.js');

const {
  UNIQUE_CONSTRAINT_ID1,
  UNIQUE_CONSTRAINT_ID2
} = require('../../../../src/constants.js');

const { 
    UlidField,
    StringField,
    CreateDateField,
    ModifiedDateField
} = require('../../../../src/fields.js');


const { App } = require('./app.js');
const { Document } = require('./document.js');
const { DocumentPermission } = require('./document-permission.js');
const { Session } = require('./session.js');
const { ConnectionMapping } = require('./connection-mapping.js');


class User extends BaoModel {
  static modelPrefix = 'u';
  static iterable = true;
  static iterationBuckets = 10;
  
  static fields = {
    userId: UlidField({ autoAssign: true, required: true }),
    email: StringField({ required: true }),
    name: StringField({ required: true }),
    avatarUrl: StringField(),
    provider: StringField({ required: true }),
    providerId: StringField({ required: true }),
    createdAt: CreateDateField(),
    modifiedAt: ModifiedDateField(),
  };

  static primaryKey = PrimaryKeyConfig('userId', 'modelPrefix');


  static uniqueConstraints = {
    uniqueEmail: UniqueConstraintConfig('email', UNIQUE_CONSTRAINT_ID1),
    uniqueProvider: UniqueConstraintConfig('providerId', UNIQUE_CONSTRAINT_ID2),
  };

  async queryApps(skCondition = null, options = {}) {
    const results = await App.queryByIndex(
      'appsForOwner',
      this._getPkValue(),
      skCondition,
      options
    );

    return results;
  }
  async queryDocumentsByCreator(skCondition = null, options = {}) {
    const results = await Document.queryByIndex(
      'documentsByCreator',
      this._getPkValue(),
      skCondition,
      options
    );

    return results;
  }
  async queryPermissions(skCondition = null, options = {}) {
    const results = await DocumentPermission.queryByIndex(
      'permissionsForUser',
      this._getPkValue(),
      skCondition,
      options
    );

    return results;
  }
  async querySessions(skCondition = null, options = {}) {
    const results = await Session.queryByIndex(
      'sessionsForUser',
      this._getPkValue(),
      skCondition,
      options
    );

    return results;
  }
  async queryConnections(skCondition = null, options = {}) {
    const results = await ConnectionMapping.queryByIndex(
      'connectionsForUser',
      this._getPkValue(),
      skCondition,
      options
    );

    return results;
  }

  static async findByEmail(value) {
    return await this.findByUniqueConstraint('uniqueEmail', value);
  }

  static async findByProvider(value) {
    return await this.findByUniqueConstraint('uniqueProvider', value);
  }

}

module.exports = { User };
